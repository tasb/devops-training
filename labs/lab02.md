<!-- no toc -->
# Lab 02 - Full CI/CD

On this lab you'll complete to create your full CI/CD pipeline that will deploy your Todo App on Azure infrastructure created through Infra as Code approach

## On this lab

- [Prerequisites](#Prerequisites)
- [Application Architecture](#application-architecture)
- [Configure GitHub repo](#configure-github-repo)
- [Create Azure Storage](#create-azure-storage)
- [Create Terraform scripts](#create-terraform-scripts)
- [Update GitHub workflows](#update-github-workflows)
- [Run your pipeline](#run-your-pipeline)
- [Enable security tools](#enable-security-tools)
- [Create SAST pipeline](#create-SAST-pipeline)
- [Clean up your resources](#clean-up-your-resources)

## Prerequisites

To complete this lab you need:

- Completed [Lab 01 - Plan, Build & Test](lab01.md), or
- Complete the following steps of [Lab 01 - Plan, Build & Test](lab01.md):
  - [Getting Started](lab01.md#getting-started)
  - [Enforce Pull Request Usage](lab01.md#enforce-pull-request-usage)

## Application Architecture

During this lab you'll work on as simple ToDo List app with the following architecture.

![ToDo App Arch](images/lab01/image01.png "ToDo App Arch")

At the end this lab you will create the following infrastructure representing Staging (`stg`) and Production (`prod`) environment

![Application Architecture](./images/lab02/image01.png "Application Architecture")

Resources to be created:

- 1 resource group per each environment and each application component
  - This is mandatory since in Azure all resources need to be create inside a [Resource Group](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/manage-resource-groups-portal#what-is-a-resource-group)
- 1 App Service Plan per each environment and each web component (Todo WebApp & Todo API)
  - [App Service Plan](https://docs.microsoft.com/en-us/azure/app-service/overview-hosting-plans) defines a set of compute resources for a web app to run.
- 1 Azure Database for PostgreSQL per environment
  - [Azure Database for PostgreSQL](https://docs.microsoft.com/en-us/azure/postgresql/single-server/overview) is a relational database service in the Microsoft cloud based on the PostgreSQL open source relational database

---
**NOTE**

All resources from all training audience will be created on the same subscription so you need to create a prefix for all your resources. But default, let's use the initials of your name.

For example: Yangchen Casalinho EspÃ­rito Santo[^1] = yces

[^1]: Name generated by [Gerador de Nomes](https://gerador-nomes.herokuapp.com/)

---

## Configure GitHub repo

---
**NOTE**

You'll receive on private Teams chat your Azure credentials with following format.

```JSON
{
  "clientId": "XXXXXXXXXXXXXXXXXXXXXXX",
  "clientSecret": "XXXXXXXXXXXXXXXXXXXXXXX",
  "subscriptionId": "XXXXXXXXXXXXXXXXXXXXXXX",
  "tenantId": "XXXXXXXXXXXXXXXXXXXXXXX",
  "resourceManagerEndpointUrl": "https://management.azure.com/"
}
```

---

First, you need to add your credentials as secrets on your repo.

Navigate to Settings > Secrets > Actions, click on `New repository secret` and repeat the process to create 5 secrets with following details:

1) Name: `AZURE_CREDENTIALS` // Value: JSON received on your private chat
2) Name: `ARM_CLIENT_ID` // Value: Property `clientId` from the JSON
3) Name: `ARM_CLIENT_SECRET` // Value: Property `clientSecret` from the JSON
4) Name: `ARM_SUBSCRIPTION_ID` // Value: Property `subscriptionId` from the JSON
5) Name: `ARM_TENANT_ID` // Value: Property `tenantId` from the JSON

Then, let's create the environments to be used by your CD pipeline.

Navigate to Settings > Environments and click on `New environment`.

First, you may create Staging environment. On environment name add `stg` and click on `Configure environment`.

On the new screen, click on the `Add Secret` link at the end the screen and fill the form with the following parameters:

- Name: `DB_PASSWORD`
- Value: `P@ssw0rd`

Finally, let's create Production environment. Repeat the process clicking on `New environment` button and set environment name as `prod`.

On the new screen, click on the `Add Secret` link at the end the screen and fill the form with the following parameters:

- Name: `DB_PASSWORD`
- Value: `P@ssw0rd`

In order to better protect this environment, you will add two protection rules to it.

On `Environment protection rules` block, enable `Required reviewers` checkbox and add your GitHub username on the input box.

You need to click on `Save protection rules` to save this setting. Any other setting don't need to be explicit saved.

Doing this you are creating a pre-approval gate on your production environment, meaning someone (on this case, you) need to explicitly approve the deployment on the production environment.

Then, on `Deployment branches` block, click on the dropdown and select `Selected branches` option. Now you need to define from which repo branch are you allowed to deploy to this environment.

Click on `Add deployment branch rule` and set `main` on `Branch name pattern:` input box.

## Create Azure Storage

You need an Azure Storage to keep your Terraform state to be used when you execute your pipeline and have access to last know state created by Terraform tool.

Navigate to [Azure Portal](https://portal.azure.com/) and login with your company credentials (due to SSO you may automatically be logged in).

On top search box, search for `Storage Accounts` and click on the result with the same name as stated on following image.

![Search for Storage Account](./images/lab02/image03.png "Search for Storage Account")

Then you may click on `Create storage account` button in the middle of the page.

![Create Storage Account](./images/lab02/image04.png "Create Storage Account")

You start the wizard to create your Storage Account. You need to configure 3 fields:

1) Resource Group
   - Click on the link `Create new` below dropdown box
   - On resource group name add `<your-prefix>-tfstate-rg`
   - Click on `OK`
2) Storage account name
   - Storage accounts on Azure need to have an unique on ALL Azure subscription
   - Name is mandatory to be all in small caps
   - Add the following name `<your-prefix>tfstatestg`
3) Region
   - Select `West Europe`

Click on `Review + Create` button for Azure Resource Manager validate your configuration.

After that validation finished successfully, `Create` button will turn blue and you may click on it.

The process to create your storage account just started and you need to wait a couple of minutes until have access to your resource.

When the creation finished with success you get a screen like this.

![Storage Account created](./images/lab02/image05.png "Storage Account created")

To finalize this configuration, you need to create a container inside your Azure Storage Account.

A container can be seen as a folder and is where Terraform state files will be stored.

Click on `Go to resource` blue button and you get access to all details and configurations of your Azure Storage.

Click on `Containers` option on left side bar, then on `+ Container` and finally add `tfstate` as container name and select `Blob (anonymous read access for blobs only)` as `Public access level` and to finalize click on `Create` button.

![Storage Account container](./images/lab02/image06.png "Storage Account container")

Now you have everything ready to start to implement your Infra as Code scripts and update (or create) your workflows.

## Create Terraform scripts

After you have the repo cloned on your machine you need to create a new branch to start to develop any additional code since you enable the need to use Pull Requests to update `main` branch.

To be sure you have last version, do a clean up on your local repo. First, move your repo to `main` branch.

```bash
git checkout main
```

Then, get all update from this remote repo.

```bash
git pull
```

Now you're ready to create a new branch named `add-iac`.

```bash
git checkout -b add-iac
```

Create two new folders:

1) `deploy` > `terraform` > `todo-api`
2) `deploy` > `terraform` > `todo-webapp`

Inside each folder you will create the Terraform files needed to deploy (and then destroy) your infrastructure:

- `main.tf`: main file where you define resources to be created
- `variables.tf`: each block of this file defines a variable/parameter to be used on your IaC process to make it more dynamic
- `terraform.tfvars`: where you define default values for variables/parameters defined on `variables.tf` file
- `output.tf`: where you define outputs of your IaC scripts that can be used during your CD process to set some variables

On `todo-api` folder, create a file named `variables.tf` with following content.

```hcl
variable "env" {
    type = string
    description = "Environment name to deploy"
    nullable = false
}

variable "location" {
    type = string
    description = "The Azure Region in which all resources in this example should be created."
    default = "westeurope"
}

variable "appName" {
    type = string
    description = "Application Name"
    nullable = false
}

variable "appServiceName" {
    type = string
    description = "App Service Name"
    nullable = false
}

variable "dbName" {
    type = string
    description = "Db Name"
    nullable = false
}

variable "dbAdmin" {
    type = string
    description = "Db Name"
    nullable = false
}

variable "dbPassword" {
    type = string
    description = "Db Name"
    nullable = false
    sensitive = true
}
```

Then create a `terraform.tfvars` file with the following content. Pay attention where you need to replace `<your-prefix>` with your unique prefix.

```hcl
appName = "<your-prefix>-todoapp"
appServiceName = "api"
dbName = "<your-prefix>-todoapp-db"
dbAdmin = "postgres"
```

After that, let's define your outputs that will be used during CD. Create a file named `output.tf` with following content.

```hcl
output "webappName" {
    value = "${azurerm_linux_web_app.webapp.name}"
}

output "webappUrl" {
    value = "${azurerm_linux_web_app.webapp.name}.azurewebsites.net"
}

output "dbAddress" {
    value = "${azurerm_postgresql_flexible_server.db.fqdn}"
}
```

Finally, let's create `main.tf` where you define the resources to be created, uses variables defined previously and set outputs at the end of the execution. 

The file must have the following content and you need to pay attention where you need to replace `<your-prefix>` with your unique prefix.

```hcl
terraform {
  backend "azurerm" {
        resource_group_name  = "<your-prefix>-tfstate-rg"
        storage_account_name = "<your-prefix>tfstatestg"
        container_name       = "tfstate"
        key                  = "terraform.tfstate"
    }
}

provider "azurerm" {
  features {}
}

# Creates a Resource Group to group the followinf resources
resource "azurerm_resource_group" "rg" {
  name     = "${var.appName}-${var.appServiceName}-${var.env}-rg"
  location = var.location
}

# Create the Linux App Service Plan
resource "azurerm_service_plan" "appserviceplan" {
  name                = "asp-${var.appName}-${var.appServiceName}-${var.env}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  os_type             = "Linux"
  sku_name            = "B2"
}

#Create the web app, pass in the App Service Plan ID
resource "azurerm_linux_web_app" "webapp" {
  name                = "${var.appName}-${var.appServiceName}-${var.env}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  service_plan_id     = azurerm_service_plan.appserviceplan.id

  site_config {
    always_on = true
    application_stack {
      dotnet_version = "6.0"
    }
  }
}

# Create Azure Database for PostgreSQL server. Database will be automatically created by Todo API code
resource "azurerm_postgresql_flexible_server" "db" {
  name                   = "${var.dbName}-${var.env}-psql"
  resource_group_name    = azurerm_resource_group.rg.name
  location               = azurerm_resource_group.rg.location
  version                = "13"
  administrator_login    = "${var.dbAdmin}"
  administrator_password = "${var.dbPassword}"
  zone                   = "1"

  storage_mb = 32768

  sku_name   = "B_Standard_B1ms"
}

# Add firewall rule on your Azure Database for PostgreSQL server to allow other Azure services to reach it
resource "azurerm_postgresql_flexible_server_firewall_rule" "example" {
  name             = "AllowAllAzureServicesAndResourcesWithinAzureIps"
  server_id        = azurerm_postgresql_flexible_server.db.id
  start_ip_address = "0.0.0.0"
  end_ip_address   = "0.0.0.0"
}
```

If you take a look again on `variables.tf` file you may find the following variable.

```hcl
variable "env" {
    type = string
    description = "Environment name to deploy"
    nullable = false
}
```

With this variables used as a input parameter you may reuse the same Terraform code to create your infrastructure for Staging and Production environment, following best practices on IaC approach that states that the way you create your resources on several environments must be always the same.

Now let's add the files to create Todo Webapp infrastructure.

On `todo-webapp` folder, create a file named `variables.tf` with following content.

```hcl
variable "env" {
    type = string
    description = "Environment name to deploy"
    nullable = false
}

variable "appName" {
    type = string
    description = "Application Name"
    nullable = false
}

variable "appServiceName" {
    type = string
    description = "Application Name"
    nullable = false
}

variable "apiName" {
    type = string
    description = "Application Name"
    nullable = false
}

variable "location" {
    type = string
    description = "The Azure Region in which all resources in this example should be created."
    default = "westeurope"
}
```

Then create a `terraform.tfvars` file with the following content. Pay attention where you need to replace `<your-prefix>` with your unique prefix.

```hcl
appName = "<your-prefix>-todoapp"
appServiceName = "webapp"
apiName = "api"
```

After that, let's define your outputs that will be used during CD. Create a file named `output.tf` with following content.

```hcl
output "webappName" {
    value = "${azurerm_linux_web_app.webapp.name}"
}

output "webappUrl" {
    value = "${azurerm_linux_web_app.webapp.name}.azurewebsites.net"
}

output "webapiUrl" {
    value = "${var.appName}-${var.apiName}-${var.env}.azurewebsites.net"
}
```

Finally, let's create `main.tf` where you define the resources to be created, uses variables defined previously and set outputs at the end of the execution. 

The file must have the following content and you need to pay attention where you need to replace `<your-prefix>` with your unique prefix.

```hcl
terraform {
  backend "azurerm" {
        resource_group_name  = "<your-prefix>-tfstate-rg"
        storage_account_name = "<your-prefix>tfstatestg"
        container_name       = "tfstate"
        key                  = "terraform.tfstate"
    }
}

provider "azurerm" {
  features {}
}

resource "azurerm_resource_group" "rg" {
  name     = "${var.appName}-${var.appServiceName}-${var.env}-rg"
  location = var.location
}

# Create the Linux App Service Plan
resource "azurerm_service_plan" "appserviceplan" {
  name                = "asp-${var.appName}-${var.appServiceName}-${var.env}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  os_type             = "Linux"
  sku_name            = "B2"
}

#Create the web app, pass in the App Service Plan ID, and deploy code from a public GitHub repo
resource "azurerm_linux_web_app" "webapp" {
  name                = "${var.appName}-${var.appServiceName}-${var.env}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  service_plan_id     = azurerm_service_plan.appserviceplan.id

  site_config {
    always_on = true
    application_stack {
      dotnet_version = "6.0"
    }
  }
}
```

You complete the step to create Terraform scripts. But now you only have code, you need to execute this scripts.

Let's proceed to create GitHub Workflows that will run Terraform commands during CD process.

## Update GitHub workflows

## Run your pipeline

## Enable security tools

## Create SAST pipelinee

## Clean up your resources
